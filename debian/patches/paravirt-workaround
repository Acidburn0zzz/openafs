Work around versions of Linux that don't export the paravirt_ops table
for non-GPL modules, but which redirect core functions through it.  This
has been fixed in Linux 2.6.22, so this patch can be dropped when 2.6.22
makes it into testing.

--- openafs.orig/src/afs/LINUX/osi_groups.c
+++ openafs/src/afs/LINUX/osi_groups.c
@@ -230,6 +230,7 @@
     struct key *old;
     char desc[20];
     unsigned long not_in_quota;
+    unsigned long f;
     int code = -EINVAL;
 
     if (!__key_type_keyring)
@@ -265,11 +266,11 @@
     }
 
     /* install the keyring */
-    spin_lock_irq(&task->sighand->siglock);
+    SIG_LOCK(task, f);
     old = task->signal->session_keyring;
     smp_wmb();
     task->signal->session_keyring = keyring;
-    spin_unlock_irq(&task->sighand->siglock);
+    SIG_UNLOCK(task, f);
 
     if (old)
 	    key_put(old);
--- openafs.orig/src/afs/LINUX/osi_machdep.h
+++ openafs/src/afs/LINUX/osi_machdep.h
@@ -55,14 +55,14 @@
 #endif
 
 #if defined (STRUCT_TASK_STRUCT_HAS_SIGMASK_LOCK)
-#define SIG_LOCK(X) spin_lock_irq(&X->sigmask_lock)
-#define SIG_UNLOCK(X) spin_unlock_irq(&X->sigmask_lock)
+#define SIG_LOCK(X,flags) spin_lock_irqsave(&X->sigmask_lock,flags)
+#define SIG_UNLOCK(X),flags spin_unlock_irqrestore(&X->sigmask_lock,flags)
 #elif defined (STRUCT_TASK_STRUCT_HAS_SIGHAND)
-#define SIG_LOCK(X) spin_lock_irq(&X->sighand->siglock)
-#define SIG_UNLOCK(X) spin_unlock_irq(&X->sighand->siglock)
+#define SIG_LOCK(X,flags) spin_lock_irqsave(&X->sighand->siglock,flags)
+#define SIG_UNLOCK(X,flags) spin_unlock_irqrestore(&X->sighand->siglock,flags)
 #else
-#define SIG_LOCK(X) spin_lock_irq(&X->sig->siglock)
-#define SIG_UNLOCK(X) spin_unlock_irq(&X->sig->siglock)
+#define SIG_LOCK(X,flags) spin_lock_irqsave(&X->sig->siglock,flags)
+#define SIG_UNLOCK(X,flags) spin_unlock_irqrestore(&X->sig->siglock,flags)
 #endif
 
 #if defined (STRUCT_TASK_STRUCT_HAS_RLIM)
--- openafs.orig/src/afs/LINUX/osi_misc.c
+++ openafs/src/afs/LINUX/osi_misc.c
@@ -353,10 +353,11 @@
 void
 osi_linux_mask(void)
 {
-    SIG_LOCK(current);
+    unsigned long f;
+    SIG_LOCK(current, f);
     sigfillset(&current->blocked);
     RECALC_SIGPENDING(current);
-    SIG_UNLOCK(current);
+    SIG_UNLOCK(current, f);
 }
 
 void
--- openafs.orig/src/afs/LINUX/osi_sleep.c
+++ openafs/src/afs/LINUX/osi_sleep.c
@@ -244,19 +244,20 @@
 afs_osi_Sleep(void *event)
 {
     sigset_t saved_set;
+    unsigned long f;
 
-    SIG_LOCK(current);
+    SIG_LOCK(current,f);
     saved_set = current->blocked;
     sigfillset(&current->blocked);
     RECALC_SIGPENDING(current);
-    SIG_UNLOCK(current);
+    SIG_UNLOCK(current,f);
 
     afs_osi_SleepSig(event);
 
-    SIG_LOCK(current);
+    SIG_LOCK(current,f);
     current->blocked = saved_set;
     RECALC_SIGPENDING(current);
-    SIG_UNLOCK(current);
+    SIG_UNLOCK(current,f);
 }
 
 /* osi_TimedSleep
--- openafs.orig/src/rx/LINUX/rx_kmutex.c
+++ openafs/src/rx/LINUX/rx_kmutex.c
@@ -104,11 +104,12 @@
     MUTEX_EXIT(l);
 
     if (!sigok) {
-	SIG_LOCK(current);
+	unsigned long f;
+	SIG_LOCK(current,f);
 	saved_set = current->blocked;
 	sigfillset(&current->blocked);
 	RECALC_SIGPENDING(current);
-	SIG_UNLOCK(current);
+	SIG_UNLOCK(current,f);
     }
 
     while(seq == cv->seq) {
@@ -144,10 +145,11 @@
     set_current_state(TASK_RUNNING);
 
     if (!sigok) {
-	SIG_LOCK(current);
+	unsigned long f;
+	SIG_LOCK(current, f);
 	current->blocked = saved_set;
 	RECALC_SIGPENDING(current);
-	SIG_UNLOCK(current);
+	SIG_UNLOCK(current, f);
     }
 
     if (isAFSGlocked)
