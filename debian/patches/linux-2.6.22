Add support for the kernel structure changes in 2.6.22.  Pulled from the
upstream stable branch, will be in 1.4.5.

--- openafs.orig/acinclude.m4
+++ openafs/acinclude.m4
@@ -611,6 +611,7 @@
 		 LINUX_FS_STRUCT_FOP_HAS_FLOCK
 		 LINUX_KERNEL_LINUX_SYSCALL_H
 		 LINUX_KERNEL_LINUX_SEQ_FILE_H
+		 LINUX_KERNEL_POSIX_LOCK_FILE_WAIT_ARG
 		 LINUX_KERNEL_SELINUX
 		 LINUX_KERNEL_SOCK_CREATE
 		 LINUX_KERNEL_PAGE_FOLLOW_LINK
@@ -626,6 +627,7 @@
 		 LINUX_SCHED_STRUCT_TASK_STRUCT_HAS_EXIT_STATE
 		 LINUX_SCHED_STRUCT_TASK_STRUCT_HAS_TGID
 		 LINUX_SCHED_STRUCT_TASK_STRUCT_HAS_TODO
+		 LINUX_SCHED_STRUCT_TASK_STRUCT_HAS_THREAD_INFO
 		 LINUX_EXPORTS_TASKLIST_LOCK
 		 LINUX_GET_SB_HAS_STRUCT_VFSMOUNT
 		 LINUX_STATFS_TAKES_DENTRY
@@ -767,6 +769,9 @@
 		 if test "x$ac_cv_linux_func_recalc_sigpending_takes_void" = "xyes"; then 
 		  AC_DEFINE(RECALC_SIGPENDING_TAKES_VOID, 1, [define if your recalc_sigpending takes void])
 		 fi
+		 if test "x$ac_cv_linux_kernel_posix_lock_file_wait_arg" = "xyes" ; then
+		  AC_DEFINE(POSIX_LOCK_FILE_WAIT_ARG, 1, [define if your linux kernel uses 3 arguments for posix_lock_file])
+		 fi
 		 if test "x$ac_cv_linux_kernel_is_selinux" = "xyes" ; then
 		  AC_DEFINE(LINUX_KERNEL_IS_SELINUX, 1, [define if your linux kernel uses SELinux features])
 		 fi
@@ -812,6 +817,9 @@
 		 if test "x$ac_cv_linux_sched_struct_task_struct_has_todo" = "xyes"; then 
 		  AC_DEFINE(STRUCT_TASK_STRUCT_HAS_TODO, 1, [define if your struct task_struct has todo])
 		 fi
+		 if test "x$ac_cv_linux_sched_struct_task_struct_has_thread_info" = "xyes"; then
+		  AC_DEFINE(STRUCT_TASK_STRUCT_HAS_THREAD_INFO, 1, [define if your struct task_struct has thread_info])
+		 fi
 		 if test "x$ac_cv_linux_get_sb_has_struct_vfsmount" = "xyes"; then
 		  AC_DEFINE(GET_SB_HAS_STRUCT_VFSMOUNT, 1, [define if your get_sb_nodev needs a struct vfsmount argument])
 		 fi
--- openafs.orig/src/afs/LINUX/osi_sleep.c
+++ openafs/src/afs/LINUX/osi_sleep.c
@@ -205,7 +205,11 @@
 #if defined(STRUCT_TASK_STRUCT_HAS_TODO)
 	    !current->todo
 #else
+#if defined(STRUCT_TASK_STRUCT_HAS_THREAD_INFO)
             test_ti_thread_flag(current->thread_info, TIF_FREEZE)
+#else
+            test_ti_thread_flag(task_thread_info(current), TIF_FREEZE)
+#endif
 #endif
 #endif
 	    )
@@ -303,7 +307,11 @@
 #if defined(STRUCT_TASK_STRUCT_HAS_TODO)
 	    !current->todo
 #else
+#if defined(STRUCT_TASK_STRUCT_HAS_THREAD_INFO)
             test_ti_thread_flag(current->thread_info, TIF_FREEZE)
+#else
+            test_ti_thread_flag(task_thread_info(current), TIF_FREEZE)
+#endif
 #endif
 #endif
 	    )
--- openafs.orig/src/afs/LINUX/osi_vfsops.c
+++ openafs/src/afs/LINUX/osi_vfsops.c
@@ -292,8 +292,10 @@
 {
     struct vcache *vcp = (struct vcache *) foo;
 
+#if defined(SLAB_CTOR_VERIFY)
     if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
 	SLAB_CTOR_CONSTRUCTOR)
+#endif
 	inode_init_once(AFSTOV(vcp));
 }
 
--- openafs.orig/src/afs/LINUX/osi_vnodeops.c
+++ openafs/src/afs/LINUX/osi_vnodeops.c
@@ -473,11 +473,11 @@
 #ifdef AFS_LINUX24_ENV
     if ((code == 0 || flp->fl_type == F_UNLCK) && 
         (cmd == F_SETLK || cmd == F_SETLKW)) {
-#ifdef AFS_LINUX26_ENV
+#ifdef POSIX_LOCK_FILE_WAIT_ARG
+	code = posix_lock_file(fp, flp, 0);
+#else
 	flp->fl_flags &=~ FL_SLEEP;
 	code = posix_lock_file(fp, flp);
-#else
-	code = posix_lock_file(fp, flp, 0);
 #endif 
 	if (code && flp->fl_type != F_UNLCK) {
 	    struct AFS_FLOCK flock2;
--- openafs.orig/src/cf/linux-test4.m4
+++ openafs/src/cf/linux-test4.m4
@@ -444,6 +444,18 @@
   AC_MSG_RESULT($ac_cv_linux_sched_struct_task_struct_has_exit_state)])
 
 
+AC_DEFUN([LINUX_SCHED_STRUCT_TASK_STRUCT_HAS_THREAD_INFO], [
+  AC_MSG_CHECKING([for thread_info in struct task_struct])
+  AC_CACHE_VAL([ac_cv_linux_sched_struct_task_struct_has_thread_info], [
+    AC_TRY_KBUILD(
+[#include <linux/sched.h>],
+[struct task_struct _tsk;
+printk("%d\n", _tsk.thread_info);],
+      ac_cv_linux_sched_struct_task_struct_has_thread_info=yes,
+      ac_cv_linux_sched_struct_task_struct_has_thread_info=no)])
+  AC_MSG_RESULT($ac_cv_linux_sched_struct_task_struct_has_thread_info)])
+
+
 AC_DEFUN([LINUX_FS_STRUCT_SUPER_HAS_ALLOC_INODE], [
   AC_MSG_CHECKING([for alloc_inode in struct super_operations])
   AC_CACHE_VAL([ac_cv_linux_fs_struct_super_has_alloc_inode], [
@@ -456,6 +468,17 @@
   AC_MSG_RESULT($ac_cv_linux_fs_struct_super_has_alloc_inode)])
 
 
+AC_DEFUN([LINUX_KERNEL_POSIX_LOCK_FILE_WAIT_ARG], [
+  AC_MSG_CHECKING([for 3rd argument in posix_lock_file found in new kernels])
+  AC_CACHE_VAL([ac_cv_linux_kernel_posix_lock_file_wait_arg], [
+    AC_TRY_KBUILD(
+[#include <linux/fs.h>],
+[posix_lock_file(0,0,0);],
+      ac_cv_linux_kernel_posix_lock_file_wait_arg=yes,
+      ac_cv_linux_kernel_posix_lock_file_wait_arg=no)])
+  AC_MSG_RESULT($ac_cv_linux_kernel_posix_lock_file_wait_arg)])
+
+
 AC_DEFUN([LINUX_KERNEL_SOCK_CREATE], [
   AC_MSG_CHECKING([for 5th argument in sock_create found in some SELinux kernels])
   AC_CACHE_VAL([ac_cv_linux_kernel_sock_create_v], [
--- openafs.orig/src/rx/LINUX/rx_kmutex.c
+++ openafs/src/rx/LINUX/rx_kmutex.c
@@ -122,7 +122,11 @@
 #if defined(STRUCT_TASK_STRUCT_HAS_TODO)
 	    !current->todo
 #else
+#if defined(STRUCT_TASK_STRUCT_HAS_THREAD_INFO)
 	    test_ti_thread_flag(current->thread_info, TIF_FREEZE)
+#else
+	    test_ti_thread_flag(task_thread_info(current), TIF_FREEZE)
+#endif
 #endif
 #endif
 	    )
--- openafs.orig/src/rx/LINUX/rx_knet.c
+++ openafs/src/rx/LINUX/rx_knet.c
@@ -173,7 +173,11 @@
 #if defined(STRUCT_TASK_STRUCT_HAS_TODO)
 	    !current->todo
 #else
+#if defined(STRUCT_TASK_STRUCT_HAS_THREAD_INFO)
             test_ti_thread_flag(current->thread_info, TIF_FREEZE)
+#else
+            test_ti_thread_flag(task_thread_info(current), TIF_FREEZE)
+#endif
 #endif
 #endif
 	    )
