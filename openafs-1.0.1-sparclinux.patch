*** src/Makefile 09:50:15	1.1.1.2
--- src/Makefile 10:48:14	1.3
***************
*** 69,75 ****
  cmd: basics comerr
  	${COMPILE_PART1} cmd ${COMPILE_PART2}
  	@case ${SYS_NAME} in \
! 	sgi_6* | sun4x_57 | sun4x_58 | hp_ux11* ) \
  		${COMPILE_PART1} cmd ${COMPILE_PART2} install64 ;; \
  	esac
  
--- 69,75 ----
  cmd: basics comerr
  	${COMPILE_PART1} cmd ${COMPILE_PART2}
  	@case ${SYS_NAME} in \
! 	sgi_6* | sun4x_57 | sun4x_58 | hp_ux11* | sparc64_linux* ) \
  		${COMPILE_PART1} cmd ${COMPILE_PART2} install64 ;; \
  	esac
  
*** src/afs/afs.h 09:50:34	1.1.1.2
--- src/afs/afs.h 10:06:59	1.4
***************
*** 809,815 ****
--- 809,819 ----
       */
      ino64_t inode;			/* Unix inode for this chunk */
  #else
+ #if defined(AFS_LINUX_64BIT_KERNEL)
+     long inode;	 			/* Unix inode for this chunk */
+ #else
      afs_int32 inode;			/* Unix inode for this chunk */
+ #endif
  #endif
      afs_int32 chunkBytes;		/* Num bytes in this chunk */
      char states;		/* Has this chunk been modified? */
*** src/afs/afs_call.c 09:50:34	1.1.1.2
--- src/afs/afs_call.c 16:37:18	1.9
***************
*** 816,821 ****
--- 816,836 ----
  	}
  #endif /* AFS_SUN57_64BIT_ENV */
  
+ #if defined(AFS_LINUX_64BIT_KERNEL)
+ 	struct iparam32 dst32;
+ 
+ #ifdef AFS_SPARC64_LINUX20_ENV
+ 	if (current->tss.flags & SPARC_FLAG_32BIT) {
+ #else
+ #error Not done for this linux version
+ #endif
+ 		AFS_COPYIN(cmarg, (caddr_t) &dst32, sizeof dst32, code);
+ 		if (!code)
+ 			iparam32_to_iparam(&dst32, dst);
+ 		return code;
+ 	}
+ #endif /* AFS_LINUX_64BIT_KERNEL */
+ 
  	AFS_COPYIN(cmarg, (caddr_t) dst, sizeof *dst, code);
  	return code;
  }
***************
*** 888,896 ****
  			   long parm4)
  {
      struct afssysargs args, *uap = &args;
!     int linux_ret=0;
!     int *retval = &linux_ret;
!     int eparm[4]; /* matches AFSCALL_ICL in fstrace.c */
  #else
  #if defined(UKERNEL)
  Afs_syscall ()
--- 903,911 ----
  			   long parm4)
  {
      struct afssysargs args, *uap = &args;
!     long linux_ret=0;
!     long *retval = &linux_ret;
!     long eparm[4]; /* matches AFSCALL_ICL in fstrace.c */
  #else
  #if defined(UKERNEL)
  Afs_syscall ()
***************
*** 1114,1120 ****
  {
      extern short afs_brsDaemons;
      extern afs_int32 afs_CheckServerDaemonStarted;
!     extern struct osi_WaitHandle AFS_WaitHandler, AFS_CSWaitHandler;
      extern struct osi_file *afs_cacheInodep;
  
      AFS_STATCNT(afs_shutdown);
--- 1129,1135 ----
  {
      extern short afs_brsDaemons;
      extern afs_int32 afs_CheckServerDaemonStarted;
!     extern struct afs_osi_WaitHandle AFS_WaitHandler, AFS_CSWaitHandler;
      extern struct osi_file *afs_cacheInodep;
  
      AFS_STATCNT(afs_shutdown);
*** src/afs/afs_daemons.c 09:50:35	1.1.1.2
--- src/afs/afs_daemons.c 10:48:14	1.3
***************
*** 353,359 ****
  #ifdef AFS_LINUX22_ENV
      code = gop_lookupname((char *)ab->parm[0], AFS_UIOSYS, 1,  (struct vnode **) 0, &dp);
      if (dp)
! 	tvn = (struct vcache*)dp->d_inode;
  #else
      code = gop_lookupname((char *)ab->parm[0], AFS_UIOSYS, 1,  (struct vnode **) 0, (struct vnode **)&tvn);
  #endif
--- 353,359 ----
  #ifdef AFS_LINUX22_ENV
      code = gop_lookupname((char *)ab->parm[0], AFS_UIOSYS, 1,  (struct vnode **) 0, &dp);
      if (dp)
! 	tvn = (struct vnode*)dp->d_inode;
  #else
      code = gop_lookupname((char *)ab->parm[0], AFS_UIOSYS, 1,  (struct vnode **) 0, (struct vnode **)&tvn);
  #endif
*** src/afs/afs_osi.h 09:50:35	1.1.1.2
--- src/afs/afs_osi.h 10:06:59	1.4
***************
*** 154,160 ****
    */
  
  
! #if defined(AFS_HPUX_ENV) || defined(AFS_SUN57_ENV) || (defined(AFS_SGI61_ENV) && defined(KERNEL) && defined(_K64U64))
  typedef struct {
      afs_int32 tv_sec;
      afs_int32 tv_usec;
--- 154,160 ----
    */
  
  
! #if defined(AFS_HPUX_ENV) || defined(AFS_SUN57_ENV) || defined(AFS_LINUX_64BIT_KERNEL) || (defined(AFS_SGI61_ENV) && defined(KERNEL) && defined(_K64U64))
  typedef struct {
      afs_int32 tv_sec;
      afs_int32 tv_usec;
*** src/afs/afs_pioctl.c 09:50:35	1.1.1.2
--- src/afs/afs_pioctl.c 10:06:59	1.6
***************
*** 180,185 ****
--- 180,200 ----
  	}
  #endif /* defined(AFS_SGI_ENV) && (_MIPS_SZLONG==64) */
  
+ #if defined(AFS_LINUX_64BIT_KERNEL)
+ 	struct afs_ioctl32 dst32;
+ 
+ #ifdef AFS_SPARC64_LINUX20_ENV
+ 	if (current->tss.flags & SPARC_FLAG_32BIT) {
+ #else
+ #error Not done for this linux type
+ #endif
+ 		AFS_COPYIN(cmarg, (caddr_t) &dst32, sizeof dst32, code);
+ 		if (!code)
+ 			afs_ioctl32_to_afs_ioctl(&dst32, dst);
+ 		return code;
+ 	}
+ #endif /* defined(AFS_LINUX_64BIT_KERNEL) */
+ 
  	AFS_COPYIN(cmarg, (caddr_t) dst, sizeof *dst, code);
  	return code;
  }
***************
*** 792,798 ****
  #ifdef AFS_LINUX22_ENV
  	code = gop_lookupname(path, AFS_UIOUSER, follow,  (struct vnode **) 0, &dp);
  	if (!code)
! 	    vp = (struct vcache *)dp->d_inode;
  #else
  	code = gop_lookupname(path, AFS_UIOUSER, follow,  (struct vnode **) 0, &vp);
  #endif /* AFS_LINUX22_ENV */
--- 807,813 ----
  #ifdef AFS_LINUX22_ENV
  	code = gop_lookupname(path, AFS_UIOUSER, follow,  (struct vnode **) 0, &dp);
  	if (!code)
! 	    vp = (struct vnode *)dp->d_inode;
  #else
  	code = gop_lookupname(path, AFS_UIOUSER, follow,  (struct vnode **) 0, &vp);
  #endif /* AFS_LINUX22_ENV */
***************
*** 2753,2759 ****
        /* Note that it doesn't have a cell yet...     */
        if (!matches) {
  	 afs_uint32 temp = sp->host.s_addr;
! 	 srvr = afs_GetServer(&temp, 1, NULL, (vlonly ? AFS_VLPORT : AFS_FSPORT), 
  			      WRITE_LOCK, (afsUUID *)0,0);
  	 srvr->addr->sa_iprank = sp->rank + afs_randomMod15();
  	 afs_PutServer(srvr, WRITE_LOCK);
--- 2768,2774 ----
        /* Note that it doesn't have a cell yet...     */
        if (!matches) {
  	 afs_uint32 temp = sp->host.s_addr;
! 	 srvr = afs_GetServer(&temp, 1, 0, (vlonly ? AFS_VLPORT : AFS_FSPORT), 
  			      WRITE_LOCK, (afsUUID *)0,0);
  	 srvr->addr->sa_iprank = sp->rank + afs_randomMod15();
  	 afs_PutServer(srvr, WRITE_LOCK);
***************
*** 3318,3325 ****
--- 3333,3342 ----
  
  	if ( ainSize < sizeof(struct setspref) )
  		return EINVAL;
+ #if 0	/* num_servers is unsigned */
  	if ( sin->num_servers < 0 )
  		return EINVAL;
+ #endif
  	if ( sin->num_servers > AFS_MAX_INTERFACE_ADDR)
  		return ENOMEM;
  
*** src/afs/exporter.h 09:50:35	1.1.1.2
--- src/afs/exporter.h 10:06:59	1.4
***************
*** 33,39 ****
    * up 2 bytes
    */
  
! #if defined(AFS_SUN57_64BIT_ENV) || defined(AFS_OSF_ENV) || (defined(AFS_SGI61_ENV) && (_MIPS_SZPTR==64))
  #define	AFS_XLATOR_MAGIC	0x8765		/* XXX */
  #else
  #define	AFS_XLATOR_MAGIC	0x87654321
--- 33,39 ----
    * up 2 bytes
    */
  
! #if defined(AFS_SUN57_64BIT_ENV) || defined(AFS_OSF_ENV) || (defined(AFS_SGI61_ENV) && (_MIPS_SZPTR==64)) || defined(AFS_LINUX_64BIT_KERNEL)
  #define	AFS_XLATOR_MAGIC	0x8765		/* XXX */
  #else
  #define	AFS_XLATOR_MAGIC	0x87654321
*** src/afs/LINUX/osi_alloc.c 09:50:35	1.1.1.2
--- src/afs/LINUX/osi_alloc.c 10:06:59	1.6
***************
*** 32,39 ****
  };
  
  /* These assume 32-bit pointers */
! #define MEMTYPE(A) (((unsigned int)A) & 0x3)
! #define MEMADDR(A) (void *)((unsigned int)(A) & (~0x3))
  
  /* globals */
  afs_atomlist *al_mem_pool; /* pool of osi_linux_mem structures */
--- 32,39 ----
  };
  
  /* These assume 32-bit pointers */
! #define MEMTYPE(A) (((unsigned long)A) & 0x3)
! #define MEMADDR(A) (void *)((unsigned long)(A) & (~0x3))
  
  /* globals */
  afs_atomlist *al_mem_pool; /* pool of osi_linux_mem structures */
***************
*** 82,90 ****
  
      /*  if we can use kmalloc use it to allocate the required memory. */
      if (asize <  MAX_KMALLOC_SIZE) {
!         new = (void *)kmalloc(asize, GFP_KERNEL);
          if (new) /* piggy back alloc type */
!             (unsigned int)new |= KM_TYPE;
      }
      if (!new) { /* otherwise use vmalloc  */
  	int max_wait = 10;
--- 82,90 ----
  
      /*  if we can use kmalloc use it to allocate the required memory. */
      if (asize <  MAX_KMALLOC_SIZE) {
!         new = (void *)(long)kmalloc(asize, GFP_KERNEL);
          if (new) /* piggy back alloc type */
!             (unsigned long)new |= KM_TYPE;
      }
      if (!new) { /* otherwise use vmalloc  */
  	int max_wait = 10;
***************
*** 95,101 ****
  	    schedule();
          }
  	if (new) /* piggy back alloc type */
! 	    (unsigned int)new |= VM_TYPE;
      }
      if (new)
  	memset(MEMADDR(new), 0, asize);
--- 95,101 ----
  	    schedule();
          }
  	if (new) /* piggy back alloc type */
! 	    (unsigned long)new |= VM_TYPE;
      }
      if (new)
  	memset(MEMADDR(new), 0, asize);
***************
*** 139,145 ****
  {
      unsigned int key;
  
!     key = (unsigned int)p >> 2;
      key = (key * HASH_CONST)%HASH_PRIME;
  
      return key;
--- 139,145 ----
  {
      unsigned int key;
  
!     key = (unsigned int)(long)p >> 2;
      key = (key * HASH_CONST)%HASH_PRIME;
  
      return key;
*** src/afs/LINUX/osi_cred.c 09:50:35	1.1.1.2
--- src/afs/LINUX/osi_cred.c 10:06:59	1.4
***************
*** 48,54 ****
  	    osi_Panic("crget: No more memory for creds!\n");
  	
  	for (i=0; i < CRED_ALLOC_STEP-1; i++)
! 	    cred_pool[i].cr_ref = (int)&cred_pool[i+1];
  	cred_pool[i].cr_ref = 0;
      }
      tmp = cred_pool;
--- 48,54 ----
  	    osi_Panic("crget: No more memory for creds!\n");
  	
  	for (i=0; i < CRED_ALLOC_STEP-1; i++)
! 	    cred_pool[i].cr_ref = (long)&cred_pool[i+1];
  	cred_pool[i].cr_ref = 0;
      }
      tmp = cred_pool;
***************
*** 69,75 ****
      }
  
      CRED_LOCK();
!     cr->cr_ref = (int)cred_pool;
      cred_pool = cr;
      CRED_UNLOCK();
      ncreds_inuse --;
--- 69,75 ----
      }
  
      CRED_LOCK();
!     cr->cr_ref = (long)cred_pool;
      cred_pool = cr;
      CRED_UNLOCK();
      ncreds_inuse --;
*** src/afs/LINUX/osi_file.c 09:50:35	1.1.1.2
--- src/afs/LINUX/osi_file.c 10:48:14	1.3
***************
*** 181,187 ****
      char *aptr;
      afs_int32 asize; {
      struct AFS_UCRED *oldCred;
!     unsigned int resid;
      register afs_int32 code;
      register afs_int32 cnt1=0;
      AFS_STATCNT(osi_Read);
--- 181,187 ----
      char *aptr;
      afs_int32 asize; {
      struct AFS_UCRED *oldCred;
!     size_t resid;
      register afs_int32 code;
      register afs_int32 cnt1=0;
      AFS_STATCNT(osi_Read);
***************
*** 220,226 ****
      afs_int32 offset;
      afs_int32 asize; {
      struct AFS_UCRED *oldCred;
!     unsigned int resid;
      register afs_int32 code;
      AFS_STATCNT(osi_Write);
      if ( !afile )
--- 220,226 ----
      afs_int32 offset;
      afs_int32 asize; {
      struct AFS_UCRED *oldCred;
!     size_t resid;
      register afs_int32 code;
      AFS_STATCNT(osi_Write);
      if ( !afile )
*** src/afs/LINUX/osi_groups.c 09:50:35	1.1.1.2
--- src/afs/LINUX/osi_groups.c 10:06:59	1.5
***************
*** 101,107 ****
  {
      int code;
      cred_t *cr = crref();
!     int junk;
      int old_pag;
  
      lock_kernel();
--- 101,107 ----
  {
      int code;
      cred_t *cr = crref();
!     afs_uint32 junk;
      int old_pag;
  
      lock_kernel();
***************
*** 125,130 ****
--- 125,149 ----
  
      return code;
  }
+ 
+ #ifdef AFS_SPARC64_LINUX20_ENV
+ asmlinkage int afs_xsetgroups32(int gidsetsize, __kernel_gid_t32 *grouplist)
+ {
+ 	gid_t gl[NGROUPS];
+ 	int ret, i;
+ 	mm_segment_t old_fs = get_fs ();
+ 	
+ 	if ((unsigned) gidsetsize > NGROUPS)
+ 		return -EINVAL;
+ 	for (i = 0; i < gidsetsize; i++, grouplist++)
+ 		if (__get_user (gl[i], grouplist))
+ 			return -EFAULT;
+         set_fs (KERNEL_DS);
+ 	ret = afs_xsetgroups(gidsetsize, gl);
+ 	set_fs (old_fs);
+ 	return ret;
+ }
+ #endif
  
  static int afs_setgroups(cred_t **cr, int ngroups, gid_t *gidset, int change_parent)
  {
*** src/afs/LINUX/osi_machdep.h 09:50:36	1.1.1.2
--- src/afs/LINUX/osi_machdep.h 10:48:14	1.3
***************
*** 30,36 ****
--- 30,40 ----
  #define afs_hz HZ
  #include "../h/sched.h"
  #define osi_Time() (xtime.tv_sec)
+ #if  (CPU == sparc64)
+ #define osi_GetTime(V) do { (*##V##).tv_sec = xtime.tv_sec; (*##V##).tv_usec = xtime.tv_usec; } while (0)
+ #else
  #define osi_GetTime(V) (*(V)=xtime)
+ #endif
  
  #undef gop_lookupname
  #define gop_lookupname osi_lookupname
***************
*** 89,95 ****
--- 93,103 ----
  
  /* cred struct */
  typedef struct cred {		/* maps to task field: */
+ #if (CPU == sparc64)
+     long cr_ref;
+ #else
      int cr_ref;
+ #endif
      unsigned short cr_uid;	/* euid */
      unsigned short cr_ruid;	/* uid */
      unsigned short cr_gid;	/* egid */
*** src/afs/LINUX/osi_misc.c 09:50:36	1.1.1.2
--- src/afs/LINUX/osi_misc.c 10:06:59	1.4
***************
*** 264,269 ****
--- 264,276 ----
  void afs_osi_SetTime(osi_timeval_t *tvp)
  {
      extern int (*sys_settimeofdayp)(struct timeval *tv, struct timezone *tz);
+ #ifdef AFS_LINUX_64BIT_KERNEL
+     struct timeval tv;
+     AFS_STATCNT(osi_SetTime);
+     tv.tv_sec = tvp->tv_sec;
+     tv.tv_usec = tvp->tv_usec;
+     (void) (*sys_settimeofdayp)(&tv, NULL);
+ #else
      KERNEL_SPACE_DECL;
  
      AFS_STATCNT(osi_SetTime);
***************
*** 271,276 ****
--- 278,284 ----
      TO_USER_SPACE();
      (void) (*sys_settimeofdayp)(tvp, NULL);
      TO_KERNEL_SPACE();
+ #endif
  }
  
  /* Free all the pages on any of the vnodes in the vlru. Must be done before
*** src/afs/LINUX/osi_module.c 09:50:36	1.1.1.2
--- src/afs/LINUX/osi_module.c 10:06:59	1.8
***************
*** 26,32 ****
  asmlinkage int (*sys_killp)(int pid, int signal);
  asmlinkage int (*sys_setgroupsp)(int gidsetsize, gid_t *grouplist);
  
! extern void *sys_call_table[];
  extern struct file_system_type afs_file_system;
  
  static long get_page_offset(void);
--- 26,32 ----
  asmlinkage int (*sys_killp)(int pid, int signal);
  asmlinkage int (*sys_setgroupsp)(int gidsetsize, gid_t *grouplist);
  
! extern unsigned int sys_call_table[];  /* changed to uint because SPARC64 has syscaltable of 32bit items */
  extern struct file_system_type afs_file_system;
  
  static long get_page_offset(void);
***************
*** 42,53 ****
  /* Since sys_ni_syscall is not exported, I need to cache it in order to restore
   * it.
   */
! static void *afs_ni_syscall = NULL;
  
  int init_module(void)
  {
      extern int afs_syscall();
      extern int afs_xsetgroups();
  
      /* obtain PAGE_OFFSET value */
      afs_linux_page_offset = get_page_offset();
--- 42,78 ----
  /* Since sys_ni_syscall is not exported, I need to cache it in order to restore
   * it.
   */
! static unsigned int afs_ni_syscall = 0;
  
+ #ifdef AFS_SPARC64_LINUX20_ENV
+ static unsigned int afs_ni_syscall32 = 0;
+ asmlinkage int (*sys_setgroupsp32)(int gidsetsize, __kernel_gid_t32 *grouplist);
+ extern unsigned int sys_call_table32[];
+ 
+ asmlinkage int afs_syscall32(long syscall, long parm1, long parm2, long parm3,
+ 			     long parm4, long parm5)
+ {
+ __asm__ __volatile__ ("
+ 	srl %o4, 0, %o4
+ 	mov %o7, %i7
+ 	call afs_syscall
+ 	srl %o5, 0, %o5
+ 	ret
+ 	nop
+ ");
+ }
+ #endif
+ 
+ #define POINTER2SYSCALL (unsigned int)(unsigned long)
+ #define SYSCALL2POINTER (void *)(long)
+ 
  int init_module(void)
  {
      extern int afs_syscall();
      extern int afs_xsetgroups();
+ #ifdef AFS_SPARC64_LINUX20_ENV
+     extern int afs_xsetgroups32();
+ #endif
  
      /* obtain PAGE_OFFSET value */
      afs_linux_page_offset = get_page_offset();
***************
*** 59,84 ****
      }
  
      /* Initialize pointers to kernel syscalls. */
!     sys_settimeofdayp = sys_call_table[__NR_settimeofday];
!     sys_socketcallp = sys_call_table[__NR_socketcall];
!     sys_killp = sys_call_table[__NR_kill];
  
      /* setup AFS entry point. */
!     if (sys_call_table[__NR_afs_syscall] == afs_syscall) {
  	printf("AFS syscall entry point already in use!\n");
  	return -EBUSY;
      }
  
  
      afs_ni_syscall = sys_call_table[__NR_afs_syscall];
!     sys_call_table[__NR_afs_syscall] = afs_syscall;
  
      osi_Init();
      register_filesystem(&afs_file_system);
  
      /* Intercept setgroups calls */
!     sys_setgroupsp = sys_call_table[__NR_setgroups];
!     sys_call_table[__NR_setgroups] = afs_xsetgroups;
  
      return 0;
  }
--- 84,117 ----
      }
  
      /* Initialize pointers to kernel syscalls. */
!     sys_settimeofdayp = SYSCALL2POINTER sys_call_table[__NR_settimeofday];
!     sys_socketcallp = SYSCALL2POINTER sys_call_table[__NR_socketcall];
!     sys_killp = SYSCALL2POINTER sys_call_table[__NR_kill];
  
      /* setup AFS entry point. */
!     if (SYSCALL2POINTER sys_call_table[__NR_afs_syscall] == afs_syscall) {
  	printf("AFS syscall entry point already in use!\n");
  	return -EBUSY;
      }
  
  
      afs_ni_syscall = sys_call_table[__NR_afs_syscall];
!     sys_call_table[__NR_afs_syscall] = POINTER2SYSCALL afs_syscall;
! #ifdef AFS_SPARC64_LINUX20_ENV
!     afs_ni_syscall32 = sys_call_table32[__NR_afs_syscall];
!     sys_call_table32[__NR_afs_syscall] = POINTER2SYSCALL afs_syscall32;
! #endif
  
      osi_Init();
      register_filesystem(&afs_file_system);
  
      /* Intercept setgroups calls */
!     sys_setgroupsp = SYSCALL2POINTER sys_call_table[__NR_setgroups];
!     sys_call_table[__NR_setgroups] = POINTER2SYSCALL afs_xsetgroups;
! #ifdef AFS_SPARC64_LINUX20_ENV
!     sys_setgroupsp32 = SYSCALL2POINTER sys_call_table32[__NR_setgroups];
!     sys_call_table32[__NR_setgroups] = POINTER2SYSCALL afs_xsetgroups32;
! #endif
  
      return 0;
  }
***************
*** 87,94 ****
  {
      struct task_struct *t;
  
!     sys_call_table[__NR_setgroups] = sys_setgroupsp;
      sys_call_table[__NR_afs_syscall] = afs_ni_syscall;
  
      unregister_filesystem(&afs_file_system);
  
--- 120,131 ----
  {
      struct task_struct *t;
  
!     sys_call_table[__NR_setgroups] = POINTER2SYSCALL sys_setgroupsp;
      sys_call_table[__NR_afs_syscall] = afs_ni_syscall;
+ #ifdef AFS_SPARC64_LINUX20_ENV
+     sys_call_table32[__NR_setgroups] = POINTER2SYSCALL sys_setgroupsp32;
+     sys_call_table32[__NR_afs_syscall] = afs_ni_syscall32;
+ #endif
  
      unregister_filesystem(&afs_file_system);
  
***************
*** 100,106 ****
  
  static long get_page_offset(void)
  {
! #if defined(AFS_PPC_LINUX22_ENV)
      return PAGE_OFFSET;
  #else
      struct task_struct *p;
--- 137,143 ----
  
  static long get_page_offset(void)
  {
! #if defined(AFS_PPC_LINUX22_ENV) || defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
      return PAGE_OFFSET;
  #else
      struct task_struct *p;
*** src/afs/LINUX/osi_sleep.c 09:50:36	1.1.1.2
--- src/afs/LINUX/osi_sleep.c 12:33:16
***************
*** 16,24 ****
  
  #if defined(AFS_GLOBAL_SUNLOCK)
  static int osi_TimedSleep(char *event, afs_int32 ams, int aintok);
  void afs_osi_Wakeup(char *event);
  void afs_osi_Sleep(char *event);
- #endif
  
  static char waitV;
  
--- 16,24 ----
  
  #if defined(AFS_GLOBAL_SUNLOCK)
  static int osi_TimedSleep(char *event, afs_int32 ams, int aintok);
+ #endif
  void afs_osi_Wakeup(char *event);
  void afs_osi_Sleep(char *event);
  
  static char waitV;
  
*** src/afs/LINUX/osi_vnodeops.c 09:50:36	1.1.1.2
--- src/afs/LINUX/osi_vnodeops.c 10:48:14	1.3
***************
*** 146,151 ****
--- 146,152 ----
  static int afs_linux_readdir(struct file *fp,
  			     void *dirbuf, filldir_t filldir)
  {
+     extern struct DirEntry * afs_dir_GetBlob();
      struct vcache *avc = (struct vcache*)FILE_INODE(fp);
      struct vrequest treq;
      register struct dcache *tdc;
***************
*** 525,531 ****
  }
  
  /* Not allowed to directly read a directory. */
! int afs_linux_dir_read(struct file *fp, char *buf, size_t count, loff_t *ppos)
  {
      return -EISDIR;
  }
--- 526,532 ----
  }
  
  /* Not allowed to directly read a directory. */
! ssize_t afs_linux_dir_read(struct file *fp, char *buf, size_t count, loff_t *ppos)
  {
      return -EISDIR;
  }
*** src/afs/VNOPS/afs_vnop_lookup.c 09:50:36	1.1.1.2
--- src/afs/VNOPS/afs_vnop_lookup.c 10:06:59	1.4
***************
*** 325,331 ****
--- 325,335 ----
  #if (defined(AFS_SGI62_ENV) || defined(AFS_SUN57_64BIT_ENV))
  extern int BlobScan(ino64_t *afile, afs_int32 ablob);
  #else
+ #if defined AFS_LINUX_64BIT_KERNEL
+ extern int BlobScan(long *afile, afs_int32 ablob);
+ #else
  extern int BlobScan(afs_int32 *afile, afs_int32 ablob);
+ #endif
  #endif
  
  
*** src/afs/VNOPS/afs_vnop_readdir.c 09:50:36	1.1.1.2
--- src/afs/VNOPS/afs_vnop_readdir.c 10:06:59	1.4
***************
*** 59,65 ****
--- 59,69 ----
  #if defined(AFS_SGI62_ENV) || defined(AFS_SUN57_64BIT_ENV)
  int BlobScan(ino64_t *afile, afs_int32 ablob)
  #else
+ #ifdef AFS_LINUX_64BIT_KERNEL
+ int BlobScan(long *afile, afs_int32 ablob)
+ #else
  int BlobScan(afs_int32 *afile, afs_int32 ablob)
+ #endif
  #endif
  {
      register afs_int32 relativeBlob;
*** src/config/Makefile.sparc64_linux22 May  5 22:32:27 1998
--- src/config/Makefile.sparc64_linux22 Dec 22 14:37:51 2000
***************
*** 0 ****
--- 1,50 ----
+ # Copyright 1998 Transarc Corporation 
+ #
+ # Keep macros within each section in sorted order for clean diff displays.
+ #
+ # AFS_OSTYPE used to indicate suffixes and os specific subdirectories.
+ AFS_OSTYPE = LINUX
+ 
+ # Base directory for linux kernel source. Actually a prefix which is complete
+ # when LINUX_VERS is appended to it.
+ LINUX_SRCDIR = /usr/src/linux-
+ # Default list of Linux kernels to build. Build will run only if all
+ # can be built. To build a different set, specify LINUX_VERS to make.
+ LINUX_VERS = 2.2.14
+ 
+ #
+ # compilation and link editor flags
+ DBG=-g
+ OPTMZ=-O2
+ PAM_CFLAGS = -O2 -Dlinux -DLINUX_PAM -fPIC
+ # Put -O2 here to _ensure_ all Makefiles pick it up.
+ XCFLAGS= -O2
+ MT_CFLAGS=-DAFS_PTHREAD_ENV -pthread -D_REENTRANT ${XCFLAGS}
+ XLDFLAGS=
+ SHARE_LDFLAGS = -shared -Xlinker -x
+ SHLIB_SUFFIX=so
+ SHLIB_CFLAGS=
+ #
+ # libraries
+ MTLIBS=-lpthread
+ TXLIBS= /usr/lib/libncurses.so
+ XLIBS=
+ #
+ # programs
+ AR=ar
+ AS=as
+ CP=cp
+ INSTALL=${SRCDIR}bin/install
+ LD=ld   
+ MT_CC=cc
+ MV=mv
+ RANLIB=ranlib
+ RM=rm
+ WASHTOOL=${SRCDIR}bin/washtool
+ #
+ # Other OS specific requirements
+ #
+ YACC = bison -y
+ LEX = flex -l
+ # Used in des library.
+ CRYPT_OBJ = crypt.o
*** src/config/Makefile.sparc_linux22 May  5 22:32:27 1998
--- src/config/Makefile.sparc_linux22 Dec 22 14:37:51 2000
***************
*** 0 ****
--- 1,50 ----
+ # Copyright 1998 Transarc Corporation 
+ #
+ # Keep macros within each section in sorted order for clean diff displays.
+ #
+ # AFS_OSTYPE used to indicate suffixes and os specific subdirectories.
+ AFS_OSTYPE = LINUX
+ 
+ # Base directory for linux kernel source. Actually a prefix which is complete
+ # when LINUX_VERS is appended to it.
+ LINUX_SRCDIR = /usr/src/linux-
+ # Default list of Linux kernels to build. Build will run only if all
+ # can be built. To build a different set, specify LINUX_VERS to make.
+ LINUX_VERS = 2.2.14
+ 
+ #
+ # compilation and link editor flags
+ DBG=-g
+ OPTMZ=-O2
+ PAM_CFLAGS = -O2 -Dlinux -DLINUX_PAM -fPIC
+ # Put -O2 here to _ensure_ all Makefiles pick it up.
+ XCFLAGS= -O2
+ MT_CFLAGS=-DAFS_PTHREAD_ENV -pthread -D_REENTRANT ${XCFLAGS}
+ XLDFLAGS=
+ SHARE_LDFLAGS = -shared -Xlinker -x
+ SHLIB_SUFFIX=so
+ SHLIB_CFLAGS=
+ #
+ # libraries
+ MTLIBS=-lpthread
+ TXLIBS= /usr/lib/libncurses.so
+ XLIBS=
+ #
+ # programs
+ AR=ar
+ AS=as
+ CP=cp
+ INSTALL=${SRCDIR}bin/install
+ LD=ld   
+ MT_CC=cc
+ MV=mv
+ RANLIB=ranlib
+ RM=rm
+ WASHTOOL=${SRCDIR}bin/washtool
+ #
+ # Other OS specific requirements
+ #
+ YACC = bison -y
+ LEX = flex -l
+ # Used in des library.
+ CRYPT_OBJ = crypt.o
*** src/config/afs_sysnames.h 09:50:41	1.1.1.2
--- src/config/afs_sysnames.h 10:48:14	1.3
***************
*** 114,119 ****
--- 114,124 ----
  #define SYS_NAME_ID_ppc_linux22         1601
  #define SYS_NAME_ID_ppc_linux24         1602
  
+ #define SYS_NAME_ID_sparc_linux2	1700
+ #define SYS_NAME_ID_sparc_linux22	1701
+ 
+ #define SYS_NAME_ID_sparc64_linux2	1800
+ #define SYS_NAME_ID_sparc64_linux22	1801
  
  
  /*
*** src/config/param.sparc64_linux22.h May  5 22:32:27 1998
--- src/config/param.sparc64_linux22.h Dec 22 12:58:37 2000
***************
*** 0 ****
--- 1,79 ----
+ /* Copyright (C) 1998 by Transarc Corporation */
+ 
+ 
+ #ifndef _PARAM_SPARC64_LINUX22_H_
+ #define _PARAM_SPARC64_LINUX22_H_
+ 
+ /* In user space the AFS_LINUX20_ENV should be sufficient. In the kernel,
+  * it's a judgment call. If something is obviously sparc64 specific, use that
+  * #define instead. Note that "20" refers to the linux 2.0 kernel. The "2"
+  * in the sysname is the current version of the client. This takes into
+  * account the perferred OS user space configuration as well as the kernel.
+  */
+ 
+ #define AFS_LINUX20_ENV	1
+ #define AFS_LINUX22_ENV	1
+ #define AFS_SPARC64_LINUX20_ENV	1
+ #define AFS_SPARC64_LINUX22_ENV	1
+ #define AFS_LINUX_64BIT_KERNEL 1
+ #define AFS_NONFSTRANS 1
+ 
+ #define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+ #define AFS_SYSCALL 227
+ #define AFS_64BIT_IOPS_ENV  1
+ #define AFS_NAMEI_ENV     1   /* User space interface to file system */
+ 
+ #define AFS_64BIT_ENV		1	/* Defines afs_int32 as int, not long. */
+ #define AFS_32BIT_USR_ENV	1	/* user level processes are 32bit */
+ #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits. */
+ 
+ #include <afs/afs_sysnames.h>
+ 
+ #define AFS_USERSPACE_IP_ADDR 1
+ #define RXK_LISTENER_ENV 1
+ #define AFS_GCPAGS		0       /* if nonzero, garbage collect PAGs */
+ 
+ /* Machine / Operating system information */
+ #define SYS_NAME	"sparc64_linux22"
+ #define SYS_NAME_ID	SYS_NAME_ID_sparc64_linux22
+ #define AFSBIG_ENDIAN    1
+ #define AFS_HAVE_FFS        1       /* Use system's ffs. */
+ #define AFS_HAVE_STATVFS    0	/* System doesn't support statvfs */
+ #define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+ 
+ #if defined(__KERNEL__) && !defined(KDUMP_KERNEL)
+ #include <linux/config.h>
+ #ifdef CONFIG_SMP
+ #undef CONFIG_SMP
+ #endif
+ /* Using "AFS_SMP" to map to however many #define's are required to get
+  * MP to compile for Linux
+  */
+ #ifdef AFS_SMP
+ #define CONFIG_SMP
+ #define __SMP__
+ #define AFS_GLOBAL_SUNLOCK
+ #endif
+ 
+ #endif /* __KERNEL__  && !DUMP_KERNEL*/
+ 
+ #ifdef KERNEL
+ #ifndef MIN
+ #define MIN(A,B) ((A) < (B) ? (A) : (B))
+ #endif
+ #ifndef MAX
+ #define MAX(A,B) ((A) > (B) ? (A) : (B))
+ #endif
+ #endif /* KERNEL */
+ 
+ /* on sparclinux is O_LARGEFILE defined but there is not off64_t,
+    so small hack to get usd_file.c work */
+ #ifndef KERNEL
+ #define __USE_FILE_OFFSET64 1
+ #define __USE_LARGEFILE64 1
+ #if !defined off64_t
+ #define off64_t __off64_t
+ #endif
+ #endif
+ 
+ #endif /* _PARAM_SPARC64_LINUX20_H_ */
*** src/config/param.sparc64_linux22_usr.h May  5 22:32:27 1998
--- src/config/param.sparc64_linux22_usr.h Dec 22 12:10:53 2000
***************
*** 0 ****
--- 1,56 ----
+ /* Copyright (C) 1998 by Transarc Corporation */
+ 
+ 
+ #ifndef _PARAM_USR_SPARC64_LINUX22_H_
+ #define _PARAM_USR_SPARC64_LINUX22_H_
+ 
+ /* In user space the AFS_LINUX20_ENV should be sufficient. In the kernel,
+  * it's a judgment call. If something is obviously sparc64 specific, use that
+  * #define instead. Note that "20" refers to the linux 2.0 kernel. The "2"
+  * in the sysname is the current version of the client. This takes into
+  * account the perferred OS user space configuration as well as the kernel.
+  */
+ 
+ #define UKERNEL			1	/* user space kernel */
+ #define AFS_ENV			1
+ #define AFS_USR_LINUX20_ENV	1
+ #define AFS_USR_LINUX22_ENV	1
+ #define AFS_NONFSTRANS 1
+ 
+ #define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+ #define AFS_SYSCALL 227
+ #define AFS_64BIT_IOPS_ENV  1
+ #define AFS_NAMEI_ENV     1   /* User space interface to file system */
+ #include <afs/afs_sysnames.h>
+ 
+ #define AFS_USERSPACE_IP_ADDR 1
+ #define RXK_LISTENER_ENV 1
+ #define AFS_GCPAGS		0       /* if nonzero, garbage collect PAGs */
+ 
+ 
+ /* Machine / Operating system information */
+ #define SYS_NAME	"sparc64_linux22"
+ #define SYS_NAME_ID	SYS_NAME_ID_sparc64_linux22
+ #define AFSBIG_ENDIAN    1
+ #define AFS_HAVE_FFS        1       /* Use system's ffs. */
+ #define AFS_HAVE_STATVFS    0	/* System doesn't support statvfs */
+ #define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+ 
+ #define	afsio_iov	uio_iov
+ #define	afsio_iovcnt	uio_iovcnt
+ #define	afsio_offset	uio_offset
+ #define	afsio_seg	uio_segflg
+ #define	afsio_fmode	uio_fmode
+ #define	afsio_resid	uio_resid
+ #define	AFS_UIOSYS	1
+ #define	AFS_UIOUSER	UIO_USERSPACE
+ #define	AFS_CLBYTES	MCLBYTES
+ #define	AFS_MINCHANGE	2
+ #define	VATTR_NULL	usr_vattr_null
+ 
+ #define AFS_DIRENT
+ #ifndef CMSERVERPREF
+ #define CMSERVERPREF
+ #endif
+ 
+ #endif /* _PARAM_USR_SPARC64_LINUX22_H_ */
*** src/config/param.sparc_linux22.h May  5 22:32:27 1998
--- src/config/param.sparc_linux22.h Dec 22 12:58:26 2000
***************
*** 0 ****
--- 1,81 ----
+ /* Copyright (C) 1998 by Transarc Corporation */
+ 
+ 
+ #ifndef _PARAM_SPARC_LINUX22_H_
+ #define _PARAM_SPARC_LINUX22_H_
+ 
+ /* In user space the AFS_LINUX20_ENV should be sufficient. In the kernel,
+  * it's a judgment call. If something is obviously sparc specific, use that
+  * #define instead. Note that "20" refers to the linux 2.0 kernel. The "2"
+  * in the sysname is the current version of the client. This takes into
+  * account the perferred OS user space configuration as well as the kernel.
+  */
+ 
+ #define AFS_LINUX20_ENV	1
+ #define AFS_LINUX22_ENV	1
+ #define AFS_SPARC_LINUX20_ENV	1
+ #define AFS_SPARC_LINUX22_ENV	1
+ #define AFS_NONFSTRANS 1
+ 
+ #define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+ #define AFS_SYSCALL 227
+ #define AFS_64BIT_IOPS_ENV  1
+ #define AFS_NAMEI_ENV     1   /* User space interface to file system */
+ #include <afs/afs_sysnames.h>
+ 
+ #define AFS_USERSPACE_IP_ADDR 1
+ #define RXK_LISTENER_ENV 1
+ #define AFS_GCPAGS		0       /* if nonzero, garbage collect PAGs */
+ 
+ 
+ /* Machine / Operating system information */
+ #define SYS_NAME	"sparc_linux22"
+ #define SYS_NAME_ID	SYS_NAME_ID_sparc_linux22
+ #define AFSBIG_ENDIAN    1
+ #define AFS_HAVE_FFS        1       /* Use system's ffs. */
+ #define AFS_HAVE_STATVFS    0	/* System doesn't support statvfs */
+ #define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+ 
+ #if defined(__KERNEL__) && !defined(KDUMP_KERNEL)
+ #include <linux/config.h>
+ #ifdef CONFIG_SMP
+ #undef CONFIG_SMP
+ #endif
+ /* Using "AFS_SMP" to map to however many #define's are required to get
+  * MP to compile for Linux
+  */
+ #ifdef AFS_SMP
+ #define CONFIG_SMP
+ #define __SMP__
+ #define AFS_GLOBAL_SUNLOCK
+ #endif
+ 
+ #endif /* __KERNEL__  && !DUMP_KERNEL*/
+ 
+ #ifdef KERNEL
+ #ifndef MIN
+ #define MIN(A,B) ((A) < (B) ? (A) : (B))
+ #endif
+ #ifndef MAX
+ #define MAX(A,B) ((A) > (B) ? (A) : (B))
+ #endif
+ #endif /* KERNEL */
+ 
+ #if defined(AFS_SMP) && defined(CONFIG_MODVERSIONS)
+ /* hack, I don't know what else with theese symbols */
+ #define _do_spin_lock _do_spin_lock_R__ver__do_spin_lock
+ #define _do_spin_unlock _do_spin_unlock_R__ver__do_spin_unlock
+ #define kernel_flag kernel_flag_R__ver_kernel_flag
+ #endif
+ 
+ /* on sparclinux is O_LARGEFILE defined but there is not off64_t,
+    so small hack to get usd_file.c work */
+ #ifndef KERNEL
+ #define __USE_FILE_OFFSET64 1
+ #define __USE_LARGEFILE64 1
+ #if !defined off64_t
+ #define off64_t __off64_t
+ #endif
+ #endif
+ 
+ #endif /* _PARAM_SPARC_LINUX20_H_ */
*** src/config/param.sparc_linux22_usr.h May  5 22:32:27 1998
--- src/config/param.sparc_linux22_usr.h Dec 22 12:10:34 2000
***************
*** 0 ****
--- 1,56 ----
+ /* Copyright (C) 1998 by Transarc Corporation */
+ 
+ 
+ #ifndef _PARAM_USR_SPARC_LINUX22_H_
+ #define _PARAM_USR_SPARC_LINUX22_H_
+ 
+ /* In user space the AFS_LINUX20_ENV should be sufficient. In the kernel,
+  * it's a judgment call. If something is obviously sparc specific, use that
+  * #define instead. Note that "20" refers to the linux 2.0 kernel. The "2"
+  * in the sysname is the current version of the client. This takes into
+  * account the perferred OS user space configuration as well as the kernel.
+  */
+ 
+ #define UKERNEL			1	/* user space kernel */
+ #define AFS_ENV			1
+ #define AFS_USR_LINUX20_ENV	1
+ #define AFS_USR_LINUX22_ENV	1
+ #define AFS_NONFSTRANS 1
+ 
+ #define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+ #define AFS_SYSCALL 227
+ #define AFS_64BIT_IOPS_ENV  1
+ #define AFS_NAMEI_ENV     1   /* User space interface to file system */
+ #include <afs/afs_sysnames.h>
+ 
+ #define AFS_USERSPACE_IP_ADDR 1
+ #define RXK_LISTENER_ENV 1
+ #define AFS_GCPAGS		0       /* if nonzero, garbage collect PAGs */
+ 
+ 
+ /* Machine / Operating system information */
+ #define SYS_NAME	"sparc_linux22"
+ #define SYS_NAME_ID	SYS_NAME_ID_sparc_linux22
+ #define AFSBIG_ENDIAN    1
+ #define AFS_HAVE_FFS        1       /* Use system's ffs. */
+ #define AFS_HAVE_STATVFS    0	/* System doesn't support statvfs */
+ #define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+ 
+ #define	afsio_iov	uio_iov
+ #define	afsio_iovcnt	uio_iovcnt
+ #define	afsio_offset	uio_offset
+ #define	afsio_seg	uio_segflg
+ #define	afsio_fmode	uio_fmode
+ #define	afsio_resid	uio_resid
+ #define	AFS_UIOSYS	1
+ #define	AFS_UIOUSER	UIO_USERSPACE
+ #define	AFS_CLBYTES	MCLBYTES
+ #define	AFS_MINCHANGE	2
+ #define	VATTR_NULL	usr_vattr_null
+ 
+ #define AFS_DIRENT
+ #ifndef CMSERVERPREF
+ #define CMSERVERPREF
+ #endif
+ 
+ #endif /* _PARAM_USR_SPARC_LINUX22_H_ */
*** src/des/andrew-conf.h 09:50:41	1.1.1.2
--- src/des/andrew-conf.h 10:48:14	1.3
***************
*** 44,50 ****
--- 44,58 ----
  #ifdef AFS_PPC_LINUX20_ENV
  #include "conf-ppc-linux.h"
  #else
+ #ifdef AFS_SPARC_LINUX20_ENV
+ #include "conf-sparc-linux.h"
+ #else
+ #ifdef AFS_SPARC64_LINUX20_ENV
+ #include "conf-sparc64-linux.h"
+ #else
  #include "conf-i386-linux.h"
+ #endif /* AFS_SPARC64_LINUX20_ENV */
+ #endif /* AFS_SPARC_LINUX20_ENV */
  #endif
  #else
  Sorry, you lose.
*** src/des/conf-sparc-linux.h May  5 22:32:27 1998
--- src/des/conf-sparc-linux.h Dec 22 14:37:52 2000
***************
*** 0 ****
--- 1,15 ----
+ /*
+  * Copyright 1988 by the Massachusetts Institute of Technology.
+  *
+  * For copying and distribution information, please see the file
+  * <mit-copyright.h>.
+  *
+  * Machine-type definitions: Linux on Intel
+  */
+ 
+ #include <mit-cpyright.h>
+ 
+ #define BITS32
+ #define BIG
+ #define MSBFIRST
+ #define MUSTALIGN
*** src/des/conf-sparc64-linux.h May  5 22:32:27 1998
--- src/des/conf-sparc64-linux.h Dec 22 14:37:52 2000
***************
*** 0 ****
--- 1,15 ----
+ /*
+  * Copyright 1988 by the Massachusetts Institute of Technology.
+  *
+  * For copying and distribution information, please see the file
+  * <mit-copyright.h>.
+  *
+  * Machine-type definitions: Linux on Intel
+  */
+ 
+ #include <mit-cpyright.h>
+ 
+ #define BITS32
+ #define BIG
+ #define MSBFIRST
+ #define MUSTALIGN
*** src/libafs/MakefileProto.LINUX 09:50:43	1.1.1.2
--- src/libafs/MakefileProto.LINUX 15:24:19	1.5
***************
*** 41,46 ****
--- 41,57 ----
  	-fno-strength-reduce -pipe -m486 -malign-loops=2 -malign-jumps=2 \
  	-malign-functions=2
  DEFINES = -D__KERNEL__  -DCPU=586 -DKERNEL -D_KERNEL -DMODULE ${SMP_DEF}
+ <sparc_linux22 sparc_linux24>
+ LD = ld -m elf32_sparc
+ CCFLAGS =   -O2 -fomit-frame-pointer \
+ 	-fno-strength-reduce -pipe -mcpu=v8 -mno-fpu -fcall-used-g5 -fcall-used-g7
+ DEFINES = -D__KERNEL__  -DCPU=sparc -DKERNEL -D_KERNEL -DMODULE ${SMP_DEF}
+ <sparc64_linux22 sparc64_linux24>
+ CC = sparc64-linux-gcc
+ LD = ld -m elf64_sparc
+ CCFLAGS =   -O2 -fomit-frame-pointer \
+ 	-fno-strength-reduce -pipe -mcpu=ultrasparc -m64 -mno-fpu -mcmodel=medlow -ffixed-g4 -fcall-used-g5 -fcall-used-g7 -Wno-sign-compare
+ DEFINES = -D__KERNEL__  -DCPU=sparc64 -DKERNEL -D_KERNEL -DMODULE ${SMP_DEF}
  <ppc_linux22 ppc_linux24>
  CCFLAGS =   -O2 -fomit-frame-pointer -fno-strength-reduce \
  	-fno-strict-aliasing -fsigned-char -msoft-float -pipe \
***************
*** 95,100 ****
--- 106,115 ----
  		ln -s ${LINUX_SRCDIR}$$v/include/asm-i386 asm ; \
  <ppc_linux22 ppc_linux24>
  		ln -s ${LINUX_SRCDIR}$$v/include/asm-ppc asm ; \
+ <sparc_linux22 sparc_linux24>
+ 		ln -s ${LINUX_SRCDIR}$$v/include/asm-sparc asm ; \
+ <sparc64_linux22 sparc64_linux24>
+ 		ln -s ${LINUX_SRCDIR}$$v/include/asm-sparc64 asm ; \
  <all>
  		for m in ${MPS} ; do \
  			KDIR=${KOBJ}-$$v-$$m ; \
*** src/lwp/lwp.c 09:50:44	1.1.1.2
--- src/lwp/lwp.c 10:48:14	1.3
***************
*** 342,351 ****
--- 342,357 ----
  	savecontext(Create_Process_Part2, &temp2->context,
  		    stackptr+stacksize-16); /* 16 = 2 * jmp_buf_type*/
  #else
+ #if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
  	savecontext(Create_Process_Part2, &temp2->context,
+ 		    stackptr+stacksize-0x40); /* lomgjmp does something
+ 						 with %fp + 0x38 */
+ #else
+ 	savecontext(Create_Process_Part2, &temp2->context,
  		    stackptr+stacksize-sizeof(void *));
  #endif
  #endif
+ #endif
  	/* End of gross hack */
  
  	Set_LWP_RC();
***************
*** 463,470 ****
--- 469,481 ----
  	    savecontext(Dispatcher, &(temp -> context),
  			&(LWPANCHOR.dsptchstack[(sizeof LWPANCHOR.dsptchstack)-8]));
  #else
+ #if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
  	    savecontext(Dispatcher, &(temp -> context),
+ 			&(LWPANCHOR.dsptchstack[(sizeof LWPANCHOR.dsptchstack)-0x40]));
+ #else
+ 	    savecontext(Dispatcher, &(temp -> context),
  			&(LWPANCHOR.dsptchstack[(sizeof LWPANCHOR.dsptchstack)-sizeof(void *)]));
+ #endif
  #endif
  #endif
  	}
*** src/lwp/lwp.h 09:50:44	1.1.1.2
--- src/lwp/lwp.h 10:48:14	1.3
***************
*** 193,199 ****
  #else
  struct lwp_context {	/* saved context for dispatcher */
      char *topstack;	/* ptr to top of process stack */
! #ifdef sparc
  #ifdef	save_allregs
      int globals[7+1+32+2+32+2];    /* g1-g7, y reg, f0-f31, fsr, fq, c0-c31, csr, cq. */
  #else
--- 193,199 ----
  #else
  struct lwp_context {	/* saved context for dispatcher */
      char *topstack;	/* ptr to top of process stack */
! #if defined(sparc) && !defined(__linux__)
  #ifdef	save_allregs
      int globals[7+1+32+2+32+2];    /* g1-g7, y reg, f0-f31, fsr, fq, c0-c31, csr, cq. */
  #else
*** src/lwp/preempt.c 09:50:44	1.1.1.2
--- src/lwp/preempt.c 10:48:14	1.3
***************
*** 95,98 ****
      return(LWP_SUCCESS);
      }
  
! #endif /* AFS_I386_LINUX20_ENV */
--- 95,98 ----
      return(LWP_SUCCESS);
      }
  
! #endif /* AFS_LINUX20_ENV */
*** src/lwp/process.c 09:50:44	1.1.1.2
--- src/lwp/process.c 15:24:19	1.5
***************
*** 33,40 ****
  #elif	defined(AFS_LINUX20_ENV)
  #if defined(AFS_PPC_LINUX20_ENV)
  #define LWP_SP 0
! #else
  #define LWP_SP 4
  #endif
  #else
       Need offset to SP in jmp_buf for this platform.
--- 33,48 ----
  #elif	defined(AFS_LINUX20_ENV)
  #if defined(AFS_PPC_LINUX20_ENV)
  #define LWP_SP 0
! #elif   defined(AFS_I386_LINUX20_ENV)
  #define LWP_SP 4
+ #elif   defined(AFS_SPARC_LINUX20_ENV)
+ #define LWP_SP 0
+ #define LWP_FP 1
+ #elif   defined(AFS_SPARC64_LINUX20_ENV) && defined(AFS_32BIT_USR_ENV)
+ #define LWP_SP 0
+ #define LWP_FP 1
+ #else
+ #error Unsupported linux LWP system type.
  #endif
  #else
       Need offset to SP in jmp_buf for this platform.
***************
*** 97,102 ****
--- 105,113 ----
  				{
  				case 0: jmpBuffer = (jmp_buf_type *)jmp_tmp;
  					jmpBuffer[LWP_SP] = (jmp_buf_type)sp; 
+ #if defined(AFS_SPARC_LINUX20_ENV) || (defined(AFS_SPARC64_LINUX20_ENV) && defined(AFS_32BIT_USR_ENV))
+ 					jmpBuffer[LWP_FP] = (jmp_buf_type)sp; 
+ #endif
  				   	longjmp(jmp_tmp,1);
  				   	break;
  				case 1: (*EP)();
*** src/rx/rx.c 09:50:47	1.1.1.2
--- src/rx/rx.c 10:07:00	1.4
***************
*** 4927,4933 ****
  					     (char *)call, istack);
  #else /* RX_ENABLE_LOCKS */
  	    call->resendEvent = rxevent_Post(&retryTime, rxi_Start,
! 					     (char *)call, (void*)istack);
  #endif /* RX_ENABLE_LOCKS */
  	  }
  	}
--- 4927,4933 ----
  					     (char *)call, istack);
  #else /* RX_ENABLE_LOCKS */
  	    call->resendEvent = rxevent_Post(&retryTime, rxi_Start,
! 					     (char *)call, (void*)(long)istack);
  #endif /* RX_ENABLE_LOCKS */
  	  }
  	}
*** src/rx/rx_clock.h 09:50:47	1.1.1.2
--- src/rx/rx_clock.h 10:32:48
***************
*** 83,89 ****
  #else /* KERNEL */
  #include "../afs/afs_osi.h"
  #define clock_Init()
! #if defined(AFS_SGI61_ENV) || defined(AFS_HPUX_ENV)
  #define clock_GetTime(cv) osi_GetTime((osi_timeval_t *)cv)
  #else
  #define clock_GetTime(cv) osi_GetTime((struct timeval *)cv)
--- 83,89 ----
  #else /* KERNEL */
  #include "../afs/afs_osi.h"
  #define clock_Init()
! #if defined(AFS_SGI61_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_LINUX_64BIT_KERNEL)
  #define clock_GetTime(cv) osi_GetTime((osi_timeval_t *)cv)
  #else
  #define clock_GetTime(cv) osi_GetTime((struct timeval *)cv)
*** src/venus/fstrace.c 09:50:49	1.1.1.2
--- src/venus/fstrace.c 16:37:18	1.6
***************
*** 2072,2082 ****
--- 2072,2091 ----
  {
      int code;
  #ifdef AFS_LINUX20_ENV
+ #if defined AFS_LINUX_64BIT_KERNEL
+     long long eparm[4];
+     /* don't want to sign extend it to 64bit, so using ulong */
+     eparm[0] = (unsigned long)parm3;
+     eparm[1] = (unsigned long)parm4;
+     eparm[2] = (unsigned long)parm5;
+     eparm[3] = (unsigned long)parm6;
+ #else
      int eparm[4];
      eparm[0] = parm3;
      eparm[1] = parm4;
      eparm[2] = parm5;
      eparm[3] = parm6;
+ #endif
      /* Linux can only handle 5 arguments in the actual syscall. */
      if (call == AFSCALL_ICL) {
  	code = syscall(AFS_SYSCALL, call, parm0, parm1, parm2, eparm);
***************
*** 2084,2089 ****
--- 2093,2106 ----
      else {
  	code = syscall(AFS_SYSCALL, call, parm0, parm1, parm2, parm3);
      }
+ #if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
+     /* on sparc this function returns none value, so do it myself */
+     __asm__ __volatile__ ("
+ 	mov	%o0, %i0
+ 	ret
+ 	restore
+ ");
+ #endif
  #else
  #if !defined(AFS_SGI_ENV) && !defined(AFS_AIX32_ENV)
      code =  syscall(AFS_SYSCALL, call, parm0, parm1, parm2, parm3, parm4);
*** src/venus/kdump.c 09:50:49	1.1.1.2
--- src/venus/kdump.c 10:48:14	1.4
***************
*** 211,216 ****
--- 211,218 ----
  #define _LINUX_TIME_H
  #define _LINUX_FCNTL_H
  #define _I386_STATFS_H
+ #define _SPARC_STATFS_H
+ #define _SPARC64_STATFS_H
  struct timezone {
      int a,b;
  };
***************
*** 219,224 ****
--- 221,227 ----
      int tv_usec;
  } timeval_t; /* Needed here since KERNEL defined. */
  #define _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+ #define _LINUX_BYTEORDER_BIG_ENDIAN_H
  #include <linux/version.h>
  #include <linux/fs.h>
  #include <afs/osi_vfs.h>
***************
*** 1892,1898 ****
  #endif
  }
  
! #if	defined(sparc)
  int readmem(kmem, buf, vad, len)
      int kmem, len;
  #ifdef AFS_SUN57_ENV
--- 1895,1901 ----
  #endif
  }
  
! #if	defined(sparc) && !defined(__linux__)
  int readmem(kmem, buf, vad, len)
      int kmem, len;
  #ifdef AFS_SUN57_ENV
***************
*** 1990,1996 ****
  	}
      }
  #else
! #if	defined(sparc)
  #ifndef AFS_SUN5_ENV
      if (mem) {
  #endif
--- 1993,1999 ----
  	}
      }
  #else
! #if	defined(sparc) && !defined(__linux__)
  #ifndef AFS_SUN5_ENV
      if (mem) {
  #endif
***************
*** 2103,2109 ****
  #else /* AFS_KDUMP_LIB */
      int fd;
  
! #if	defined(sparc)
  #ifndef	AFS_SUN5_ENV
      if (mem) {
  #endif
--- 2106,2112 ----
  #else /* AFS_KDUMP_LIB */
      int fd;
  
! #if	defined(sparc) && !defined(__linux__)
  #ifndef	AFS_SUN5_ENV
      if (mem) {
  #endif
*** src/volser/volmain.c 09:50:51	1.1.1.2
--- src/volser/volmain.c 10:48:14	1.3
***************
*** 163,169 ****
  #ifndef AFS_LINUX20_ENV
    old = signal(SIGSYS, SIG_IGN);	
  #endif
!   rcode = syscall (31 /* AFS_SYSCALL */, 28 /* AFSCALL_CALL */, a3, a4, a5);
  #ifndef AFS_LINUX20_ENV
    signal(SIGSYS, old);	
  #endif
--- 163,169 ----
  #ifndef AFS_LINUX20_ENV
    old = signal(SIGSYS, SIG_IGN);	
  #endif
!   rcode = syscall (AFS_SYSCALL /* AFS_SYSCALL */, 28 /* AFSCALL_CALL */, a3, a4, a5);
  #ifndef AFS_LINUX20_ENV
    signal(SIGSYS, old);	
  #endif
